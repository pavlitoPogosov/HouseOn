# houseon-front

## Разработка

Проект создан с помощью [Create React App](https://github.com/facebook/create-react-app).

Используется менеджер пакетов `yarn`.

Рекомендуется перед началом активной разработки почитать следующие доки:

- [react](https://reactjs.org/docs/getting-started.html)
- [react-router](https://reacttraining.com/react-router/web/guides/quick-start)
- [create-react-app](https://facebook.github.io/create-react-app/docs/documentation-intro)
- [prostore](http://gitlab.com/proscom/prostore)
- [learnrxjs.io](https://www.learnrxjs.io) (опционально, полезно, чтобы лучше понимать реактивное программирование и prostore и не только)

Перед стартом нового проекта рекомендуется обновить зависимости,
подняв версии в package.json до актуальных.

Не забудьте вписать название и краткое описание сайта
в файлы `public/index.html` и `public/manifest.json`
([подробнее про манифест](https://developers.google.com/web/fundamentals/web-app-manifest))
и в `App.js` (только название).

## Быстрый старт

```
yarn install
yarn run start
```

## clsx

Для совмещения нескольких классов в JSX-элементе используйте `clsx`:

```typescript jsx
import s from './Component.module.scss';

function Component({ enabled }) {
  return (
    <div
      className={clsx(s.Component, {
        [s.Component_enabled]: enabled
      })}
    />
  );
}
```

## React-router

Для маршрутизации используется react-router v5.
Основные маршруты определяются в файле `./src/routes/index.js`.

На каждый маршрут необходимо создавать свою папку соответствующую пути маршрута.
В этой папке должен располагаться компонент страницы, соответствующей маршруту.
Он должен называться `<Path>Page`, где `<Path>` соответствует названию папки.
Например, `IndexPage` или `MainPage`.
Компонент страницы должен быть экспортирован с помощью `export default`.
Это позволит в будущем использовать lazy loading и bundle splitting.

Чтобы делать ссылки между страницами без перезагрузки, надо использовать компонент `Link` вместо тега `a`.

Если потребуется делать программный переход между страницами, то надо использовать
`history` из react-router. Его можно инжектировать в компонент с помощью хука `useHistory`.

Для удобной работы с адресной строкой и хранения частей стейта приложения в query-параметрах
следует использовать LocationStore из
[prostore-react-router](https://gitlab.com/proscom/prostore/-/tree/master/packages/prostore-react-router).
См. примеры использования в файлах TestPage.tsx и FilterPage.tsx.

## Названия страниц

Названия страниц рекомендуется проставлять с помощью библиотеки [`react-helmet`](https://github.com/nfl/react-helmet).

Следует выработать общий принцип именования страниц и использовать его.
Пользователи часто видят только левую часть тайтла (пару слов) и иконку.
Название как правило состоит из нескольких иерархичных частей.
Сайт идентифицируется свой иконкой, поэтому в названии слева имеет смысл выносить более частные вещи.
В правой части тайтла следует приписывать название сайта.
Части названия соединяются через длинное тире EMDASH (`—`).

Часто на сайтах используется бывают страницы каких-то сущностей и страницы списков каких-то сущностей.
В таком случае, можно использовать такие варианты:

- "Имя сущности" - "Тип сущности" - "Название сайта" (например, "Иван Васильевич — Пользователи — Proscom"). Тип сущности можно опускать, если его можно вывести из имени.
- "Тип сущности во множественном числа" - "Название сайта" (например, "Пользователи — Proscom"). Тип сущности можно трактовать абстрактно без привязки к бекенду и изменять его в зависимости от потребностей (например "Активные пользователи — Proscom").
- Редактирование - "Имя сущности" - "Тип сущности" - "Название сайта" (например, "Редактирование — Иван Васильевич — Пользователи — Proscom")

## Компоненты

Компоненты раскладываются по папкам в соответствии с их использованием на сайте.
Общие для всего сайта компоненты кладутся в `./src/common`.
Компоненты, относящиеся к какому-то определенному маршруту -- в соответствующую папку внутри `./src/routes/`.

Для экспорта компонентов, не являющихся компонентами страниц, не рекомендуется использовать `export default`.

Рекомендуется проставлять всем компонентам типы для props с помощью [`prop-types`](https://reactjs.org/docs/typechecking-with-proptypes.html).

## SASS

Рекомендуется создавать отдельный `.scss`-файл для каждого компонента.
`.scss` файл должен быть импортирован в `.js` файле компонента (см. пример [App.js](./src/App.js)).

Рекомендуется использовать css-модули для стилей компонентов.
Для этого файл должен заканчиваться на `.module.scss`, а стили,
прописанные в нём, импортируются с помощью `import s from './App.module.scss`.

Не следует использовать SASS-`@import` для добавления css-стилей в текущий файл.
Исключение составляет импорт стилей из библиотек, например, `reset.css` в `index.scss`.
При импорте стилей из зависимых библиотек, следует использовать символ `~` вот так: `@import "~library/path/to/css"`.
Можно импортировать `scss`-файлы, содержащие переменные, миксины и т.п.,
но не содержащие css-стилей (селекторов).
Такие файлы рекомендуется называть с нижним подчеркиванием в начале названия, например `_text.scss`, `_tokens.scss`, `_vars.scss`.

По-умолчанию `url()` в scss обрабатывается вебпаком, поэтому все ссылки
на ассеты должны быть относительно `.scss`-файла и расположены в папке `src`.
При использовании `@import`, ссылки должны быть относительно наиболее родительского `scss` файла, импортируемого в `js`.
Именно поэтому лучше использовать импорт из js, и оставить `@import` внутри `scss` только для переменных и миксинов.

Используйте дизайн-токены (`_tokens.scss`), а также миксины текстовых стилей (`_text.scss`).
Все значения `z-index`, используемые на глобальном уровне (с `position: fixed` или `position: absolute` на уровне `body`),
стоит перечислять в виде переменных в файле `_tokens.scss`,
чтобы было проще контролировать наложение элементов интерфейса.
[См. также пример](https://gitlab.com/proscom/hse-design/-/blob/master/packages/core/src/z-index.scss) в проекте Дизайн-системы ВШЭ

### focus-visible

Мы используем нестандартный псевдокласс `:focus-visible` вместе с полифиллом.
Для корректной работы полифилла требуется также плагин `postcss-focus-visible`,
который не включён в `create-react-app`, поэтому необходимо использовать миксин
`focusVisible`.

Так как `:focus-visible` не только не поддерживается, но ещё и вызывает проблемы в Safari,
то миксин `focusVisible` добавляет только класс полифилла `.focus-visible`, а не псевдокласс.
Это помогает снизить вероятность проблем в этом бразуере.

Подробнее [см. в гайде](https://gitlab.com/proscom/guide/-/blob/master/components/button-focus.md#focus-visible).

## Инструментарий

Проект завуалированно (`через react-scripts`) собирается вебпаком.

Чтобы не мучаться со стилем кодирования, в проект добавлен [Prettier](http://prettier.io) и конфиг для него.
Prettier запускается сам при коммите.
В IDEA надо еще открыть `.prettierrc` и нажать на кнопку `Yes` в сообщении про
использование стиля основанного на Prettier.

Также в проекте настроен автозапуск `eslint --fix` и `stylelint --fix` при коммите.
(подробнее про [eslint](https://eslint.org/) и [stylelint](https://stylelint.io/))
Это позволяет автоматически применять стилевые решения и не задумываться о них в процессе.
Правила настроены так, что при отсутствии совсем критических ошибок, автозапуск этих
инструментов не помешает коммитить код.
Кроме того, эти инструменты позволяют отлавливать частые ошибки на этапе статического анализа кода.

Поэтому необходимо следить за тем, чтобы не было ни одного варнинга от `eslint`/`stylelint`.
В тех местах, где осознанно принято решение не следовать рекомендациям линтеров,
необходимо оставлять специальные комментарии, отключающие необходимое правило в необходимом месте:
[для eslint](https://eslint.org/docs/user-guide/configuring#disabling-rules-with-inline-comments),
[для stylelint](https://stylelint.io/user-guide/ignore-code).

Рекомендуется убедиться в том, что в используемой IDE стоят плагины для ESLint и Stylelint,
они активированы и автоматически проверяют файлы при сохранении.
Также стоит проверить, что активирован запуск git-хуков (в IDE и в git), в противном случае
инструменты не будут автоматически запускаться.

### Параметрическая сборка

Может возникнуть необходимость в разных окружениях использовать разные настройки для проекта на этапе сборки.
В этом случае рекомендуется использовать переменные окружения.
Для удобства работы с переменными окружения в проекте есть файл `.env`.
В нем должны быть определены все необходимые переменные.
В конкретном окружении они могут быть перезаписаны с помощью файла `.env.local`, который потребуется создать самостоятельно.
Файл `.env.local` не следует добавлять в репозиторий (он прописан в `.gitignore`).
Пример использования переменных окружения в коде приведен в файле [`index.js`](./src/index.js).

### Зависимости

Так как проект клиентский, рекомендуется ставить все зависимые библиотеки с помощью
`yarn add <library>`, а все, что касается инструментария для сборки
с помощью `yarn add --dev <tool>`.

### react-app-rewired

В проект установлен пакет [react-app-rewired](https://github.com/timarney/react-app-rewired),
который позволяет настраивать конфигурацию Webpack в рамках create-react-app без eject-а.
Конфигурация задаётся в файле `config-overrides.js`.

По-умолчанию в конфиг вносятся два изменения:

- подписка дев-сервера на пакеты из `node_modules/@proscom`, если задана переменная окружения
  `WATCH_NODE_MODULES_PROSCOM`.

  Эта подписка помогает при локальной разработке зависимых пакетов.
  В обычном случае рекомендуется оставить её выключенной, чтобы не нагружать компьютер
  лишними вычислениями.

- обработка соурс-мепов из зависимых пакетов.

  По-умолчанию Webpack не подгружает соурсмепы, уже существующие в пакетах в `node_modules`.
  Чтобы упростить отладку в редких сложных случаях, в конфигурацию вебпака
  добавляется `source-map-loader`, который эти соурсмепы загружает.

  Так как не во всех пакетах качественные соурсмепы, то по-умолчанию они загружаются только
  из пакетов `@proscom/*`. Если хотите загрузить соурсмеп из другого пакета, то пропишите его
  в файле `config-overrides.js` в соответствующей функции.

### Проксирование

При подключении фронтенда к бекенду можно использовать локальный прокси-сервер, чтобы
не разворачивать бекенд локально и избежать проблем с CORS.
Эта фича [встроена в CRA](https://create-react-app.dev/docs/proxying-api-requests-in-development/).

Для её конфигурации в проекте добавлен файл `src/setupProxy.js`, который настраивает
локальный прокси.

По-умолчанию проксируются запросы с `/api` на адрес, указанный в переменной окружения
`DEV_API_PROXY`.

Например, если бекенд тестового окружения доступен по адресу `https://front.proscom.tech/api`,
то пропишите этот адрес (без `/` на конце) в значение переменной `DEV_API_PROXY`.
Тогда например запрос на `http://localhost:3000/api/users` будет перенаправлен по адресу
`https://front.proscom.tech/api/users`.

## Команды

В папке проекта можно вызывать следующие команды:

- `yarn start`

  Запускает приложение в режиме разработки<br/>
  Оно доступно в браузере по адресу [http://localhost:3000](http://localhost:3000).

  Дев-сервер следит за изменениями в файлах и выполняет пересборку
  с последующим автообновлением.

- `yarn run build`

  Собирает продакшн бандл в папку `build`.
  Ее не надо коммитить. <br/>
  В продакшн режиме приложение оптимизируется и работает быстрее.

  Сборка минифицирована и дописывает хеши к именам файлов,
  чтобы минимизировать проблемы с кешированием в браузерах.

- `yarn run lint:js`

  Запускает `eslint`

- `yarn run lint:css`

  Запускает `stylelint`

## Компиляция e-mail шаблонов

> Для создания шаблонов выбран фреймворк "MJML".

 <br/>

- Шаблоны с расширением `.mjml` находятся по пути: `src/common/email/mjml`
- Скомпилированные шаблоны с расширением `.html` находятся по пути `src/common/email/html`

 <br/>
 
Для компиляции шаблонов из `src/common/email/mjml` используйте команду 
```
yarn mjml:compile
```
Данная команда соберет все файлы с расширением `.mjml` из `src/common/email/mjml` 
 и скомпилирует в `src/common/email/html` с теми же именами.
 
 <br/>
 
> Обратите внимание, что в шаблонах используются заглушки под реальные данные. 
> Эти заглушки обозначаются в двойных фигурных скобках `{{VARIABLE}}`.
> При работе с шаблонами на стороне сервера необходимо заменять эти конструкции на соответствующие данные.
